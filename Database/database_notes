1.What is PostgreSQL?
  *It is a powerful,open source object-relational database system.
  *It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness.

2.A Brief History of PostgreSQL
  *PostgreSQL,originally called Postgres,was created at UCB by a computer science professor named Michael Stonebraker.
  *Stonebraker started Postgres in 1986 as a follow-up project to its predecessor,Ingres,nowowned   by Computer Associates.

1977-1985-A project called INGRES as developed.
  *Proof-of-concept for relational databases
  *Established the company Ingres in 1980
  *Bought by Computer Associates in 1994.

1986-1994-POSTGRES
  *Development of the concepts in INGRES with a focus on object orientation and the query language-Quel
  *The code base of INGRES was not used a a basis of POSTGRES.
  *Commercialized as Illutra(Bought by Informix,bought by IBM)


1994-1995-Postgres95
  *Support for SQL was added in 1994.
  *Released as Postgres95 in 1995
  *Re-released as PostgresSQL 6.0 in 1996
  *Establishment of the PostgreSQL Global Development Team.

Key Features of PostgreSQL
  *PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. 
  *It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).

PostgreSQL supports a large part of the SQL standard and offers many modern features including the following −

Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)

3.Installation Of PostgreSQL
  *Command:-
   1. sudo apt-get update
   2. sudo apt-get upgrade
   3. sudo apt-get install postgresql postgresql-contrib

4.Start PostgreSQL CLI
  *service postgresql-To check the status of postgreSQL.
   Output:-Usage: /etc/init.d/postgresql {start|stop|restart|reload|force-reload|status}    [version ..]
  *service postgresql status-Running status of postgreSQL
  *sudo su postgres-To login into postgres
  *psql-To enter into postgreSQL terminal
  *\q-To exit the PostgreSQL CLI.

5.In PostgreSQL CLI
  * \l-To see all the databases present
  Output:-
                             List of databases
   Name    |  Owner   | Encoding | Collate | Ctype |   Access privileges   
-----------+----------+----------+---------+-------+-----------------------
 postgres  | postgres | UTF8     | en_IN   | en_IN | 
 template0 | postgres | UTF8     | en_IN   | en_IN | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_IN   | en_IN | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 test      | postgres | UTF8     | en_IN   | en_IN | 
 test1     | postgres | UTF8     | en_IN   | en_IN | 
(5 rows)
  
  * \du-To list the users
  
  Output:-
  List of roles
 Role name |                         Attributes                         | Member of 
-----------+------------------------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}

  *ALTER USER postgres WITH PASSWORD 'admin'; - To change the password of the default user    postgres.

  *CREATE USER user_1 WITH PASSWORD 'admin'; - To create new user.
  *ALTER USER user_1 WITH SUPERUSER; - To provide priveledge to the user.
  *DROP USER user_1; - To delete the user.
  *man psql-To know all the commands that can be used in psql.
  *psql -h localhost -p 5432 -U postgres DB_name - To connect to database directly

6.Datatype

*While creating a table, for each column,you specify a datatype,i.e,what kind of data you want to store in the table fields.

This enables several benefits −

*Consistency − Operations against columns of same data type give consistent results and are usually the fastest.

*Validation − Proper use of data types implies format validation of data and rejection of data outside the scope of data type.

*Compactness − As a column can store a single type of value, it is stored in a compact way.

*Performance − Proper use of data types gives the most efficient storage of data. The values stored can be processed quickly, which enhances the performance.

->Numeric Types
  *Numeric types consist of two-byte, four-byte, and eight-byte integers, four-byte and eight-byte floating-point numbers, and selectable-precision decimals. The following table lists the available types.






         Name			Storage Size	               Description				  Range
	smallint		2 bytes	small-range             integer			                -32768 to +32767
	
	integer		        4 bytes	                      typical choice for integer		-2147483648 to +2147483647
	
	bigint		        8 bytes	large-range              integer		                -9223372036854775808 to 9223372036854775807
	
	decimal		        variable	        user-specified precision,exact	                up to 131072 digits before the decimal point; up to 												                16383 digits after the decimal point
	
	numeric		        variable	        user-specified precision,exact	                up to 131072 digits before the decimal point; up to 												                 16383 digits after the decimal point
	
	real			4 bytes	                variable-precision,inexact		            6 decimal digits precision
	
	double precision	8 bytes	                variable-precision,inexact		            15 decimal digits precision
	
	smallserial		2 bytes	                small autoincrementing integer	                     1 to 32767
	
	serial			4 bytes	                 autoincrementing integer		             1 to 2147483647
	
	bigserial		8 bytes	                large autoincrementing integer	                     1 to 92233720368547758


->Monetary Types
  *The money type stores a currency amount with a fixed fractional precision. Values of the numeric, int, and bigint data types can be cast to money. Using Floating point numbers is not recommended to handle money due to the potential for rounding errors.

        Name	                     Storage Size	                                       Description	                         Range
       money	                     8 bytes	                                              currency amount	               -92233720368547758.08 to +92233720368547758.07

->Character Types
*The table given below lists the general-purpose character types available in PostgreSQL.
 
      S.No.	        Name & Description
	1		character varying(n), varchar(n)
			variable-length with limit

	2		character(n), char(n)
			fixed-length, blank padded

	3		text 
			variable unlimited length

->Binary Data Types
*The bytea data type allows storage of binary strings as in the table given below.

   Name	          Storage Size	     Description
   bytea	1 or 4 bytes plus the  actual binary string	variable-length binary string

->DATE/TIME TYPE
*PostgreSQL supports a full set of SQL date and time types, as shown in table below. Dates are counted according to the Gregorian calendar. Here, all the types have resolution of 1 microsecond / 14 digits except date type, whose resolution is day.
	
	Name		       		Storage Size		     Description			Low Value		High Value
	timestamp [(p)] 
	[without time zone ]			8 bytes	       both date and time (no time zone)	4713 BC		        294276 AD
	
	TIMESTAMPTZ				8 bytes	      both date and time, with time zone	4713 BC		        294276 AD

	date					4 bytes	date     (no time of day)			4713 BC		         5874897 AD

	time [ (p)] [ without time zone ]	8 bytes	     time of day (no date)			00:00:00		    24:00:00

	time [ (p)] with time zone		12 bytes	times of day only, with time zone	00:00:00+1459		24:00:00-1459

	interval [fields ] [(p) ]		12 bytes	time interval			       -178000000 years       178000000 years


->Boolean Type
*PostgreSQL provides the standard SQL type Boolean. The Boolean data type can have the states true, false, and a third state, unknown, which is represented by the SQL null value.

Name	Storage Size	Description
boolean	1 byte	state of true or false

->Enumerated Type
*Enumerated (enum) types are data types that comprise a static, ordered set of values. They are equivalent to the enum types supported in a number of programming languages.

Unlike other types, Enumerated Types need to be created using CREATE TYPE command. This type is used to store a static, ordered set of values. For example compass directions, i.e., NORTH, SOUTH, EAST, and WEST or days of the week as shown below −

CREATE TYPE week AS ENUM ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');


->Geometric Type
*Geometric data types represent two-dimensional spatial objects. The most fundamental type, the point, forms the basis for all of the other types.

Name	Storage Size	Representation	Description
point	16 bytes	Point on a plane	(x,y)
line	32 bytes	Infinite line (not fully implemented)	((x1,y1),(x2,y2))
lseg	32 bytes	Finite line segment	((x1,y1),(x2,y2))
box	32 bytes	Rectangular box	((x1,y1),(x2,y2))
path	16+16n bytes	Closed path (similar to polygon)	((x1,y1),...)
path	16+16n bytes	Open path	[(x1,y1),...]
polygon	40+16n	Polygon (similar to closed path)	((x1,y1),...)
circle	24 bytes	Circle	<(x,y),r> (center point and radius)


7.Array Type
PostgreSQL gives the opportunity to define a column of a table as a variable length multidimensional array. Arrays of any built-in or user-defined base type, enum type, or composite type can be created.

Declaration of Arrays
Array type can be declared as

CREATE TABLE monthly_savings (
   name text,
   saving_per_quarter integer[],
   scheme text[][]
);
or by using the keyword "ARRAY" as

CREATE TABLE monthly_savings (
   name text,
   saving_per_quarter integer ARRAY[4],
   scheme text[][]
);

Inserting values
Array values can be inserted as a literal constant, enclosing the element values within curly braces and separating them by commas. An example is shown below −

INSERT INTO monthly_savings 
VALUES (‘Manisha’, 
‘{20000, 14600, 23500, 13250}’, 
‘{{“FD”, “MF”}, {“FD”, “Property”}}’); 
Accessing Arrays
An example for accessing Arrays is shown below. The command given below will select the persons whose savings are more in second quarter than fourth quarter.

SELECT name FROM monhly_savings WHERE saving_per_quarter[2] > saving_per_quarter[4];
Modifying Arrays
An example of modifying arrays is as shown below.

UPDATE monthly_savings SET saving_per_quarter = '{25000,25000,27000,27000}'
WHERE name = 'Manisha';
or using the ARRAY expression syntax −

UPDATE monthly_savings SET saving_per_quarter = ARRAY[25000,25000,27000,27000]
WHERE name = 'Manisha';


Searching Arrays

An example of searching arrays is as shown below.

SELECT * FROM monthly_savings WHERE saving_per_quarter[1] = 10000 OR
saving_per_quarter[2] = 10000 OR
saving_per_quarter[3] = 10000 OR
saving_per_quarter[4] = 10000;
If the size of array is known, the search method given above can be used. Else, the following example shows how to search when the size is not known.

SELECT * FROM monthly_savings WHERE 10000 = ANY (saving_per_quarter);

8.CREATE DATABASE
*This command will create a database from PostgreSQL shell prompt, but you should have appropriate privilege to create a database. By default, the new database will be created by cloning the standard system database template1.

Syntax
The basic syntax of CREATE DATABASE statement is as follows −

CREATE DATABASE dbname;
where dbname is the name of a database to create.

Using createdb Command
PostgreSQL command line executable createdb is a wrapper around the SQL command CREATE DATABASE. The only difference between this command and SQL command CREATE DATABASE is that the former can be directly run from the command line and it allows a comment to be added into the database, all in one command.

9.CONNECT DATABASE
Syntax:-\c db_name

10.DROP DATABASE
This command drops a database. It removes the catalog entries for the database and deletes the directory containing the data. It can only be executed by the database owner. This command cannot be executed while you or anyone else is connected to the target database (connect to postgres or any other database to issue this command).

Syntax:- DROP DATABASE testdb;

10.CREATE TABLE
*The PostgreSQL CREATE TABLE statement is used to create a new table in any of the given database.

Syntax:-CREATE TABLE table_name(
   column1 datatype,
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
   PRIMARY KEY( one or more columns )
);
CREATE TABLE is a keyword, telling the database system to create a new table. The unique name or identifier for the table follows the CREATE TABLE statement.

eg:-create table employee(id BIGSERIAL PRIMARY KEY,first_name VARCHAR(20) NOT NULL,last_name VARCHAR(20) NOT NULL ,gender VARCHAR(5) NOT NULL,DOB DATE NOT NULL,email VARCHAR(50));

*You can verify if your table has been created successfully using \d command, which will be used to list down all the tables in an attached database.


11.DROP TABLE
The PostgreSQL DROP TABLE statement is used to remove a table definition and all associated data, indexes, rules, triggers, and constraints for that table.

Syntax
Basic syntax of DROP TABLE statement is as follows −

DROP TABLE table_name;

The message returned DROP TABLE indicates that drop command is executed successfully.

12.Schema
A schema is a named collection of tables. A schema can also contain views, indexes, sequences, data types, operators, and functions. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested. PostgreSQL statement CREATE SCHEMA creates a schema.

The basic syntax of CREATE SCHEMA is as follows −

CREATE SCHEMA name;
Where name is the name of the schema.

Syntax to Create Table in Schema
The basic syntax to create table in schema is as follows −

CREATE TABLE myschema.mytable (
...
);

Example
Let us see an example for creating a schema. Connect to the database testdb and create a schema myschema as follows −

testdb=# create schema myschema;
CREATE SCHEMA
The message "CREATE SCHEMA" signifies that the schema is created successfully.

Advantages of using a Schema
*It allows many users to use one database without interfering with each other.

*It organizes database objects into logical groups to make them more manageable.

*Third-party applications can be put into separate schemas so they do not collide with the names of other objects.


13.Insert
*The PostgreSQL INSERT INTO statement allows one to insert new rows into a table. One can insert a single row at a time or several rows as a result of a query.

Syntax:-
Basic syntax of INSERT INTO statement is as follows −

INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);

*Here, column1, column2,...columnN are the names of the columns in the table into which you want to insert data.

*The target column names can be listed in any order. The values supplied by the VALUES clause or query are associated with the explicit or implicit column list left-to-right.

Example:-
INSERT into employee(first_name,last_name,gender,DOB,email,salary)VALUES('Simran','Gupta','Female','1999-07-25','simran.gupta@gmail.com',40000),('Nimit','Mittal','Male','1996-12-06','nimit.mittal@gmail.com',60000),('Neeraj','Kumar','Male','1998-01-07','neeraj.kumar@gmail.com',20000),('Rachit','Garg','Male','1997-05-04','rachit.garg@gmail.com',50000);


14.Select

*PostgreSQL SELECT statement is used to fetch the data from a database table, which returns data in the form of result table. These result tables are called result-sets.

Syntax
The basic syntax of SELECT statement is as follows −

SELECT column1, column2, columnN FROM table_name;

Example:-
select id,salary from employee;

id | salary 
----+--------
  1 |  40000
  2 |  40000
  3 |  60000
  4 |  20000
  5 |  50000
  6 |  30000
  7 |  90000

Here, column1, column2...are the fields of a table, whose values you want to fetch. If you want to fetch all the fields available in the field then you can use the following syntax −

SELECT * FROM table_name;

Example:-Select * from employee;

 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  60000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
(7 rows)

15.Operators

*An operator is a reserved word or a character used primarily in a PostgreSQL statement's WHERE clause to perform operation(s), such as comparisons and arithmetic operations.

Operators are used to specify conditions in a PostgreSQL statement and to serve as conjunctions for multiple conditions in a statement.

*Arithmetic operators
*Comparison operators
*Logical operators
*Bitwise operators

PostgreSQL Arithmetic Operators
Assume variable a holds 2 and variable b holds 3, then −

Example

Operator	Description	                                                           Example
+	Addition - Adds values on either side of the operator	                          a + b will give 5
-	Subtraction - Subtracts right hand operand from left hand operand	          a - b will give -1
*	Multiplication - Multiplies values on either side of the operator	          a * b will give 6
/	Division - Divides left hand operand by right hand operand	                  b / a will give 1
%	Modulus - Divides left hand operand by right hand operand and returns remainder	  b % a will give 1
^	Exponentiation - This gives the exponent value of the right hand operand	  a ^ b will give 8
|/	square root	                                                                 |/ 25.0 will give 5
||/	Cube root	                                                                 ||/ 27.0 will give 3
!	factorial	                                                                  5 ! will give 120
!!	factorial (prefix operator)	                                                  !! 5 will give 120

Example:test=# 
select 2+3;
 ?column? 
----------
        5
(1 row)


PostgreSQL Comparison Operators
Assume variable a holds 10 and variable b holds 20, then −


Operator	Description	                                                                                                            Example
=	Checks if the values of two operands are equal or not, if yes then condition becomes true.	                                (a = b) is not true.
!=	Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.	                (a != b) is true.
<>	Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.	                (a <> b) is true.
>	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.	        (a > b) is not true.
<	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.	        (a < b) is true.
>=	Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.	(a >= b) is not true.
<=	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.	(a <= b) is true.

Example:-
test=# select * From employee where salary>50000;
 id | first_name | last_name | gender |    dob     |         email          | salary 
----+------------+-----------+--------+------------+------------------------+--------
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com |  60000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com    |  90000
(2 rows)


PostgreSQL Logical Operators
Here is a list of all the logical operators available in PostgresSQL.

Operator & Description	
AND

The AND operator allows the existence of multiple conditions in a PostgresSQL statement's WHERE clause.

Eg:-
test=# select * From employee where gender='Female' AND salary=40000;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
(2 rows)



NOT

The NOT operator reverses the meaning of the logical operator with which it is used. Eg. NOT EXISTS, NOT BETWEEN, NOT IN etc. This is negate operator.
	
OR

The OR operator is used to combine multiple conditions in a PostgresSQL statement's WHERE clause.
Eg:-
select * from employee where gender='Female' Or salary>40000;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  60000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000


The Bitwise operators supported by PostgreSQL are listed in the following table −

Operator	Description	                                                                                                            Example
&	Binary AND Operator copies a bit to the result if it exists in both operands.	                                                  (A & B) will give 12 which is 0000 1100
|	Binary OR Operator copies a bit if it exists in either operand.	                                                                   (A | B) will give 61 which is 0011 1101
~	Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.	                                                   (~A ) will give -61 which is 1100 0011 in 2's     c                                                                                                                                           complement form due to a signed binary number.
<<	Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.	            A << 2 will give 240 which is 1111 0000
>>	Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.	    A >> 2 will give 15 which is 0000 1111
#	bitwise XOR.	A # B will give 49 which is 00110001


Example:-
test=# select 60 | 13;
 ?column? 
----------
       61
(1 row)

test=# select (~60);
 ?column? 
----------
      -61
(1 row)


16. Expressions
An expression is a combination of one or more values, operators, and PostgresSQL functions that evaluate to a value.

PostgreSQL EXPRESSIONS are like formulas and they are written in query language. You can also use to query the database for specific set of data.

Syntax
Consider the basic syntax of the SELECT statement as follows −

SELECT column1, column2, columnN
FROM table_name
WHERE [CONDITION | EXPRESSION];
There are different types of PostgreSQL expressions, which are mentioned below −

PostgreSQL - Boolean Expressions
PostgreSQL Boolean Expressions fetch the data on the basis of matching single value. Following is the syntax −

SELECT column1, column2, columnN
FROM table_name
WHERE SINGLE VALUE MATCHTING EXPRESSION;

Example:-
test=# select * from employee where salary=40000;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000

PostgreSQL - Numeric Expression

These expressions are used to perform any mathematical operation in any query. Following is the syntax −

SELECT numerical_expression as  OPERATION_NAME
[FROM table_name WHERE CONDITION] ;

Example:-
test=# SELECT (15 + 6) AS ADDITION ;
 addition 
----------
       21

select count(*) as records from employee;
 records 
---------
       7

PostgreSQL - Date Expressions

Date Expressions return the current system date and time values and these expressions are used in various data manipulations.

Example:-
SELECT CURRENT_TIMESTAMP;
        current_timestamp         
----------------------------------
 2023-03-17 16:25:26.110529+05:30


17.Where clause

*The PostgreSQL WHERE clause is used to specify a condition while fetching the data from single table or joining with multiple tables.

*If the given condition is satisfied, only then it returns specific value from the table. You can filter out rows that you do not want included in the result-set by using the WHERE clause.

*The WHERE clause not only is used in SELECT statement, but it is also used in UPDATE, DELETE statement, etc., which we would examine in subsequent chapters.

Syntax
The basic syntax of SELECT statement with WHERE clause is as follows −

SELECT column1, column2, columnN
FROM table_name
WHERE [search_condition]

Example:-

->select * from employee where salary=40000;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
(2 rows)


->select * From employee where salary IN(40000,60000);
Shows the records where salary is either 40000 or 60000

id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  60000
(3 rows)


->select * from employee where salary NOT IN(40000,60000);
The following SELECT statement lists down all the records where salary value is neither 40000 nor 60000
 select * from employee where salary NOT IN(40000,60000);
 
id | first_name | last_name | gender |    dob     |         email          | salary 
----+------------+-----------+--------+------------+------------------------+--------
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com  |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com    |  90000


->select * from employee where salary between 40000 and 70000;

The following SELECT statement lists down all the records where salary value is in BETWEEN 40000 AND 70000

id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  60000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000


18.To calculate age from DOB
Syntax:-select age(Now(),dob) as age_person  from employee;

 age_person                
------------------------------------------
 23 years 4 mons 2 days 11:21:23.981559
 23 years 7 mons 26 days 11:21:23.981559
 26 years 3 mons 14 days 11:21:23.981559
 25 years 2 mons 13 days 11:21:23.981559
 25 years 10 mons 16 days 11:21:23.981559
 24 years 4 mons 10 days 11:21:23.981559
 33 years 7 mons 16 days 11:21:23.981559
(7 rows)

To calculate difference between 2 dates
select age('2023/02/01','2022/02/01') as age;
age   
--------
 1 year
(1 row)



18.AND Operator
*These two operators are called conjunctive operators.
*These operators provide a means to make multiple comparisons with different operators in the same PostgreSQL statement.
*The AND operator allows the existence of multiple conditions in a PostgreSQL statement's WHERE clause.
*While using AND operator, complete condition will be assumed true when all the conditions are true.
*For example [condition1] AND [condition2] will be true only when both condition1 and condition2 are true.

Syntax
The basic syntax of AND operator with WHERE clause is as follows −

SELECT column1, column2, columnN
FROM table_name
WHERE [condition1] AND [condition2]...AND [conditionN];

You can combine N number of conditions using AND operator. For an action to be taken by the PostgreSQL statement, whether it be a transaction or query, all conditions separated by the AND must be TRUE.

Example:-
test=# select * from employee where gender='Female' AND salary>30000;

 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
(3 rows)


19.OR Operator
*These two operators are called conjunctive operators.
*These operators provide a means to make multiple comparisons with different operators in the same PostgreSQL statement.
*While using OR operator, complete condition will be assumed true when at least any of the conditions is true. 
*For example [condition1] OR [condition2] will be true if either condition1 or condition2 is true.

Syntax
The basic syntax of OR operator with WHERE clause is as follows −

SELECT column1, column2, columnN
FROM table_name
WHERE [condition1] OR [condition2]...OR [conditionN]

Example:-
select * from employee where gender='Female' OR salary<=30000;

 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
(5 rows)

20. Update
*The PostgreSQL UPDATE Query is used to modify the existing records in a table.
*You can use WHERE clause with UPDATE query to update the selected rows. Otherwise, all the rows would be updated.

Update employee SET salary=55000 where id=3;
UPDATE 1
test=# select * from employee;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  55000
(7 rows)

If you want to modify all ADDRESS and SALARY column values in COMPANY table, you do not need to use WHERE clause and UPDATE query would be as follows −

testdb=# UPDATE COMPANY SET ADDRESS = 'Texas', SALARY=20000;

21.Delete

*The PostgreSQL DELETE Query is used to delete the existing records from a table.
*You can use WHERE clause with DELETE query to delete the selected rows. Otherwise, all the records would be deleted.

Syntax
The basic syntax of DELETE query with WHERE clause is as follows −

DELETE FROM table_name
WHERE [condition];
You can combine N number of conditions using AND or OR operators.

select * from employee;


 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  55000
  8 | Simranjit  | Singh     | Male   | 1996-01-12 | simranjit.singh@gmail.com     |  95000
  9 | Shubham    | Soni      | Male   | 1999-11-17 | shubham.soni@gmail.com        |  45000
(9 rows)

Example:
Delete from employee where id=9;
DELETE 1

After deletion:
id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  55000
  8 | Simranjit  | Singh     | Male   | 1996-01-12 | simranjit.singh@gmail.com     |  95000
(8 rows)


If you want to DELETE all the records from COMPANY table, you do not need to use WHERE clause with DELETE queries, which would be as follows −

testdb=# DELETE FROM employee;

22.Like
*The PostgreSQL LIKE operator is used to match text values against a pattern using wildcards.
*If the search expression can be matched to the pattern expression, the LIKE operator will return true, which is 1.

There are two wildcards used in conjunction with the LIKE operator −

*The percent sign (%)
*The underscore (_)
 
*The percent sign represents zero, one, or multiple numbers or characters.
*The underscore represents a single number or character. These symbols can be used in combinations.
*If either of these two signs is not used in conjunction with the LIKE clause, then the LIKE acts like the equals operator.

S.No.		Statement & Description
	
	1		WHERE SALARY::text LIKE '200%'
			Finds any values that start with 200

	2		WHERE SALARY::text LIKE '%200%'
			Finds any values that have 200 in any position

	3		WHERE SALARY::text LIKE '_00%'
			Finds any values that have 00 in the second and third positions

	4		WHERE SALARY::text LIKE '2_%_%'
			Finds any values that start with 2 and are at least 3 characters in length

	5		WHERE SALARY::text LIKE '%2'
			Finds any values that end with 2

	6		WHERE SALARY::text LIKE '_2%3'
			Finds any values that have 2 in the second position and end with a 3

	7		WHERE SALARY::text LIKE '2___3'
			Finds any values in a five-digit number that start with 2 and end with 3

Example:-
select * from employee where first_name Like 'S%i';

 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
(1 row)


23.Limit clause
*The PostgreSQL LIMIT clause is used to limit the data amount returned by the SELECT statement.

Syntax
The basic syntax of SELECT statement with LIMIT clause is as follows −

SELECT column1, column2, columnN
FROM table_name
LIMIT [no of rows]

The following is the syntax of LIMIT clause when it is used along with OFFSET clause −

SELECT column1, column2, columnN
FROM table_name
LIMIT [no of rows] OFFSET [row num]

LIMIT and OFFSET allow you to retrieve just a portion of the rows that are generated by the rest of the query
Offset means start number of row.

Example of Limit:-
test=# select * from employee LIMIT 4;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
(4 rows)

Example of Offset:-
select * from employee LIMIT 4 OFFSET 4;
 id | first_name | last_name | gender |    dob     |           email           | salary 
----+------------+-----------+--------+------------+---------------------------+--------
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com    |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com       |  90000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com    |  55000
  8 | Simranjit  | Singh     | Male   | 1996-01-12 | simranjit.singh@gmail.com |  95000
(4 rows)

*To print the third highest salary
select * from employee order by salary Desc Offset 2 Limit 1;
id | first_name | last_name | gender |    dob     |         email          | salary 
----+------------+-----------+--------+------------+------------------------+--------
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com |  55000
(1 row)


*To print the Nth highest salary
select * from employee order by salary Desc Offset N-1 Limit 1;

24. ORDER BY clause

*The PostgreSQL ORDER BY clause is used to sort the data in ascending or descending order, based on one or more columns.

*The basic syntax of ORDER BY clause is as follows −

SELECT column-list
FROM table_name
[WHERE condition]
[ORDER BY column1, column2, .. columnN] [ASC | DESC];

*You can use more than one column in the ORDER BY clause. 
*Make sure whatever column you are using to sort, that column should be available in column-list.

Example:-
select * from employee order by salary Desc;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  8 | Simranjit  | Singh     | Male   | 1996-01-12 | simranjit.singh@gmail.com     |  95000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  55000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
(8 rows)

25.Group By clause

*The PostgreSQL GROUP BY clause is used in collaboration with the SELECT statement to group together those rows in a table that have identical data.
*This is done to eliminate redundancy in the output and/or compute aggregates that apply to these groups.

Syntax
The basic syntax of GROUP BY clause is given below. The GROUP BY clause must follow the conditions in the WHERE clause and must precede the ORDER BY clause if one is used.

SELECT column-list
FROM table_name
WHERE [ conditions ]
GROUP BY column1, column2....columnN
ORDER BY column1, column2....columnN

select * from employee;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  55000
  8 | Simranjit  | Singh     | Male   | 1996-01-12 | simranjit.singh@gmail.com     |  95000
 10 | Simranjit  | Kaur      | Female | 1998-07-12 | simranjit.kaur@gmail.com      |  60000
(9 rows)

test=# select first_name,SUM(salary) from employee Group By first_name;
 first_name |  sum   
------------+--------
 Rachit     |  50000
 Simran     |  40000
 Nishtha    |  30000
 Nimit      |  55000
 Neeraj     |  20000
 Srishti    |  40000
 Simranjit  | 155000
 Veena      |  90000
(8 rows)

select first_name,SUM(salary) from employee Group By first_name Order by first_name desc;
 first_name |  sum   
------------+--------
 Veena      |  90000
 Srishti    |  40000
 Simranjit  | 155000
 Simran     |  40000
 Rachit     |  50000
 Nishtha    |  30000
 Nimit      |  55000
 Neeraj     |  20000

26.With clause
*with clause is used for defining a temporary relation such that the output of this temporary relation is available and is used by the 	 query that is associated with the WITH clause.
*helps to make complex query simpler , 
*eg :- without group by clause using avg of any attribute.

Syntax
The basic syntax of WITH query is as follows −

WITH
   name_for_summary_data AS (
      SELECT Statement)
   SELECT columns
   FROM name_for_summary_data
   WHERE conditions <=> (
      SELECT column
      FROM name_for_summary_data)
   [ORDER BY columns]

Example:-
test=# WITH salary_table as (select first_name,last_name,salary from employee)
select * from salary_table;
 first_name | last_name | salary 
------------+-----------+--------
 Srishti    | Garg      |  40000
 Simran     | Gupta     |  40000
 Neeraj     | Kumar     |  20000
 Rachit     | Garg      |  50000
 Nishtha    | Goel      |  30000
 Veena      | Rao       |  90000
 Nimit      | Mittal    |  55000
 Simranjit  | Singh     |  95000
 Simranjit  | Kaur      |  60000
(9 rows)


27.Having Clause
*The HAVING clause allows us to pick out particular rows where the function's result meets some condition.
*The WHERE clause places conditions on the selected columns, whereas the HAVING clause places conditions on groups created by the GROUP BY clause.
Syntax
The following is the position of the HAVING clause in a SELECT query −

SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY

*The HAVING clause must follow the GROUP BY clause in a query and must also precede the ORDER BY clause if used.
The following is the syntax of the SELECT statement, including the HAVING clause −

SELECT column1, column2
FROM table1, table2
WHERE [ conditions ]
GROUP BY column1, column2
HAVING [ conditions ]
ORDER BY column1, column2

Example:-
test=# SELECT first_name FROM employee GROUP BY first_name HAVING count(first_name) < 2;
 first_name 
------------
 Rachit
 Simran
 Nishtha
 Nimit
 Neeraj
 Srishti
 Veena
(7 rows)


28.Distinct Keyword
* DISTINCT keyword is used in conjunction with SELECT statement to eliminate all the duplicate records and fetching only unique records.

Syntax
The basic syntax of DISTINCT keyword to eliminate duplicate records is as follows −

SELECT DISTINCT column1, column2,.....columnN
FROM table_name
WHERE [condition]

Example:-
test=# select Distinct(salary) from employee;
 salary 
--------
  50000
  95000
  30000
  40000
  60000
  90000
  20000
  55000

select Distinct(first_name) from employee; 
 first_name 
------------
 Rachit
 Simran
 Nishtha
 Nimit
 Neeraj
 Srishti
 Simranjit
 Veena
(8 rows)


Advance git commmands

29.Constraints
*Constraints are the rules enforced on data columns on table.
*These are used to prevent invalid data from being entered into the database.
*This ensures the accuracy and reliability of the data in the database.


The following are commonly used constraints available in PostgreSQL.

NOT NULL Constraint − Ensures that a column cannot have NULL value.

UNIQUE Constraint − Ensures that all values in a column are different.

PRIMARY Key − Uniquely identifies each row/record in a database table.

FOREIGN Key − Constrains data based on columns in other tables.

CHECK Constraint − The CHECK constraint ensures that all values in a column satisfy certain conditions.

EXCLUSION Constraint − The EXCLUDE constraint ensures that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will return TRUE.


1.NOT NULL Constraint

By default, a column can hold NULL values. If you do not want a column to have a NULL value, then you need to define such constraint on this column specifying that NULL is now not allowed for that column. A NOT NULL constraint is always written as a column constraint.

A NULL is not the same as no data; rather, it represents unknown data.

For example, the following PostgreSQL statement creates a new table called COMPANY1 and adds five columns, three of which, ID and NAME and AGE, specify not to accept NULL values −

CREATE TABLE COMPANY1(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

2.UNIQUE Constraint
The UNIQUE Constraint prevents two records from having identical values in a particular column. In the COMPANY table, for example, you might want to prevent two or more people from having identical age.

Example
For example, the following PostgreSQL statement creates a new table called COMPANY3 and adds five columns. Here, AGE column is set to UNIQUE, so that you cannot have two records with same age −

CREATE TABLE COMPANY3(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL UNIQUE,
   ADDRESS        CHAR(50),
   SALARY         REAL    DEFAULT 50000.00
);

3.PRIMARY Key
*A primary key is a field in a table, which uniquely identifies each row/record in a database table.
*Primary keys must contain unique values.
*A primary key column cannot have NULL values.
*A table can have only one primary key
*When multiple fields are used as a primary key, they are called a composite key.

Example:-
CREATE TABLE COMPANY4(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

4.FOREIGN KEY Constraint
A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the referential integrity between two related tables. They are called foreign keys because the constraints are foreign; that is, outside the table. Foreign keys are sometimes called a referencing key.

Example
For example, the following PostgreSQL statement creates a new table called COMPANY5 and adds five columns.

CREATE TABLE COMPANY6(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
For example, the following PostgreSQL statement creates a new table called DEPARTMENT1, which adds three columns. The column EMP_ID is the foreign key and references the ID field of the table COMPANY6.

CREATE TABLE DEPARTMENT1(
   ID INT PRIMARY KEY      NOT NULL,
   DEPT           CHAR(50) NOT NULL,
   EMP_ID         INT      references COMPANY6(ID)
);



5.CHECK Constraint
The CHECK Constraint enables a condition to check the value being entered into a record. If the condition evaluates to false, the record violates the constraint and is not entered into the table.

Example
For example, the following PostgreSQL statement creates a new table called COMPANY5 and adds five columns. Here, we add a CHECK with SALARY column, so that you cannot have any SALARY as Zero.

CREATE TABLE COMPANY5(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL    CHECK(SALARY > 0)
);


6.Dropping Constraints
To remove a constraint you need to know its name. If the name is known, it is easy to drop. Else, you need to find out the system-generated name. The psql command \d table name can be helpful here. The general syntax is −

ALTER TABLE table_name DROP CONSTRAINT some_name;


30.Joins
*The PostgreSQL Joins clause is used to combine records from two or more tables in a database. A JOIN is a means for combining fields from two tables by using values common to each.

*Join Types in PostgreSQL are −

The CROSS JOIN
The INNER JOIN
The LEFT OUTER JOIN
The RIGHT OUTER JOIN
The FULL OUTER JOIN

We have 2 tables:-

Employees
id | dep_id | first_name | last_name | gender |    dob     |           email           | salary 
----+--------+------------+-----------+--------+------------+---------------------------+--------
  1 |      2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com    |  40000
  2 |      1 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com    |  60000
  3 |      3 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com    |  20000
  4 |      5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com     |  50000
  5 |      4 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@gmail.com    |  40000
  6 |      2 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com    |  60000
  7 |      3 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com       |  90000
  8 |      1 | Simranjit  | Singh     | Male   | 1996-01-12 | simranjit.singh@gmail.com |  95000
  9 |      5 | Simranjit  | Kaur      | Female | 1998-07-12 | simranjit.kaur@gmail.com  |  50000

Department
dep_id |  dept_name  
--------+-------------
      1 | HR
      2 | IT
      3 | Support
      4 | Development
      5 | Operations

Cross Join
*A CROSS JOIN matches every row of the first table with every row of the second table. 
*If the input tables have x and y columns, respectively, the resulting table will have x+y columns.

select first_name,last_name,id,dept_name from employees cross join department where dept_name = 'HR';
 first_name | last_name | id | dept_name 
------------+-----------+----+-----------
 Simran     | Gupta     |  1 | HR
 Nimit      | Mittal    |  2 | HR
 Neeraj     | Kumar     |  3 | HR
 Rachit     | Garg      |  4 | HR
 Srishti    | Garg      |  5 | HR
 Nishtha    | Goel      |  6 | HR
 Veena      | Rao       |  7 | HR
 Simranjit  | Singh     |  8 | HR
 Simranjit  | Kaur      |  9 | HR
(9 rows)



The INNER JOIN
*A INNER JOIN creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate. 
*The query compares each row of table1 with each row of table2 to find all pairs of rows, which satisfy the join-predicate.

The following is the syntax of INNER JOIN −

SELECT table1.column1, table2.column2...
FROM table1
INNER JOIN table2
ON table1.common_filed = table2.common_field;

select id,first_name,last_name,salary,dept_name from employees inner join department on employees.dep_id=department.dep_id;
 id | first_name | last_name | salary |  dept_name  
----+------------+-----------+--------+-------------
  1 | Simran     | Gupta     |  40000 | IT
  2 | Nimit      | Mittal    |  60000 | HR
  3 | Neeraj     | Kumar     |  20000 | Support
  4 | Rachit     | Garg      |  50000 | Operations
  5 | Srishti    | Garg      |  40000 | Development
  6 | Nishtha    | Goel      |  60000 | IT
  7 | Veena      | Rao       |  90000 | Support
  8 | Simranjit  | Singh     |  95000 | HR
  9 | Simranjit  | Kaur      |  50000 | Operations


The LEFT OUTER JOIN
*In case of LEFT OUTER JOIN, an inner join is performed first.
*Then, for each row in table T1 that does not satisfy the join condition with any row in table T2, a joined row is added with null values in columns of T2. 
*Thus, the joined table always has at least one row for each row in T1.

The following is the syntax of LEFT OUTER JOIN −

SELECT ... FROM table1 LEFT OUTER JOIN table2 ON conditional_expression ...

Example:-
select id,first_name,last_name,salary,dept_name from employees left outer join department on employees.dep_id=department.dep_id;
 id | first_name | last_name | salary |  dept_name  
----+------------+-----------+--------+-------------
  1 | Simran     | Gupta     |  40000 | IT
  2 | Nimit      | Mittal    |  60000 | HR
  3 | Neeraj     | Kumar     |  20000 | Support
  4 | Rachit     | Garg      |  50000 | Operations
  5 | Srishti    | Garg      |  40000 | Development
  6 | Nishtha    | Goel      |  60000 | IT
  7 | Veena      | Rao       |  90000 | Support
  8 | Simranjit  | Singh     |  95000 | HR
  9 | Simranjit  | Kaur      |  50000 | Operations
 10 | Shreya     | Khurana   |  65000 | 



The RIGHT OUTER JOIN
*First, an inner join is performed. Then, for each row in table T2 that does not satisfy the join condition with any row in table T1, a joined row is added with null values in columns of T1. This is the converse of a left join; the result table will always have a row for each row in T2.

The following is the syntax of RIGHT OUTER JOIN −

SELECT ... FROM table1 RIGHT OUTER JOIN table2 ON conditional_expression ...

Example:-
 select id,first_name,last_name,salary,dept_name from employees right outer join department on employees.dep_id=department.dep_id;
 id | first_name | last_name | salary |  dept_name  
----+------------+-----------+--------+-------------
  1 | Simran     | Gupta     |  40000 | IT
  2 | Nimit      | Mittal    |  60000 | HR
  3 | Neeraj     | Kumar     |  20000 | Support
  4 | Rachit     | Garg      |  50000 | Operations
  5 | Srishti    | Garg      |  40000 | Development
  6 | Nishtha    | Goel      |  60000 | IT
  7 | Veena      | Rao       |  90000 | Support
  8 | Simranjit  | Singh     |  95000 | HR
  9 | Simranjit  | Kaur      |  50000 | Operations


The FULL OUTER JOIN
First, an inner join is performed. Then, for each row in table T1 that does not satisfy the join condition with any row in table T2, a joined row is added with null values in columns of T2. In addition, for each row of T2 that does not satisfy the join condition with any row in T1, a joined row with null values in the columns of T1 is added.

The following is the syntax of FULL OUTER JOIN −

SELECT ... FROM table1 FULL OUTER JOIN table2 ON conditional_expression ..


31.Union Clause
*The PostgreSQL UNION clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.
*To use UNION, each SELECT must have the same number of columns selected, the same number of column expressions, the same data type, and have them in the same order but they do not have to be the same length.

Syntax
The basic syntax of UNION is as follows −

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

select id,first_name,salary,dept_name from employees inner join department on department.dep_id=employees.dep_id UNION select id,first_name,salary,dept_name from employees left outer join department on department.dep_id = employees.dep_id;
 id | first_name | salary |  dept_name  
----+------------+--------+-------------
  3 | Neeraj     |  20000 | Support
  7 | Veena      |  90000 | Support
  5 | Srishti    |  40000 | Development
  8 | Simranjit  |  95000 | HR
  6 | Nishtha    |  60000 | IT
  2 | Nimit      |  60000 | HR
  9 | Simranjit  |  50000 | Operations
  1 | Simran     |  40000 | IT
  4 | Rachit     |  50000 | Operations
 10 | Shreya     |  65000 | 


The UNION ALL Clause
The UNION ALL operator is used to combine the results of two SELECT statements including duplicate rows. The same rules that apply to UNION apply to the UNION ALL operator as well.
Syntax
The basic syntax of UNION ALL is as follows −

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION ALL

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]


ALIAS

a)alias table name
*You can rename a table or a column temporarily by giving another name, which is known as ALIAS.
*The use of table aliases means to rename a table in a particular PostgreSQL statement.
*Renaming is a temporary change and the actual table name does not change in the database.
*Syntax
The basic syntax of table alias is as follows −

SELECT column1, column2....
FROM table_name AS alias_name
WHERE [condition];


select e.id,e.first_name,d.dept_name,e.salary from employees as e , department as d where e.dep_id = d.dep_id;
 id | first_name |  dept_name  | salary 
----+------------+-------------+--------
  1 | Simran     | IT          |  40000
  2 | Nimit      | HR          |  60000
  3 | Neeraj     | Support     |  20000
  4 | Rachit     | Operations  |  50000
  5 | Srishti    | Development |  40000
  6 | Nishtha    | IT          |  60000
  7 | Veena      | Support     |  90000
  8 | Simranjit  | HR          |  95000
  9 | Simranjit  | Operations  |  50000
(9 rows)


b)alias column name

The basic syntax of column alias is as follows −

SELECT column_name AS alias_name
FROM table_name
WHERE [condition];

select e.id as Company_ID,e.first_name,d.dept_name as Department_name from employees as e,Department as d where e.dep_id=d.dep_id;
 company_id | first_name | department_name 
------------+------------+-----------------
          1 | Simran     | IT
          2 | Nimit      | HR
          3 | Neeraj     | Support
          4 | Rachit     | Operations
          5 | Srishti    | Development
          6 | Nishtha    | IT
          7 | Veena      | Support
          8 | Simranjit  | HR
          9 | Simranjit  | Operations






























 































