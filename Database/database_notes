1.What is PostgreSQL?
  *It is a powerful,open source object-relational database system.
  *It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness.

2.A Brief History of PostgreSQL
  *PostgreSQL,originally called Postgres,was created at UCB by a computer science professor named Michael Stonebraker.
  *Stonebraker started Postgres in 1986 as a follow-up project to its predecessor,Ingres,nowowned   by Computer Associates.

1977-1985-A project called INGRES as developed.
  *Proof-of-concept for relational databases
  *Established the company Ingres in 1980
  *Bought by Computer Associates in 1994.

1986-1994-POSTGRES
  *Development of the concepts in INGRES with a focus on object orientation and the query language-Quel
  *The code base of INGRES was not used a a basis of POSTGRES.
  *Commercialized as Illutra(Bought by Informix,bought by IBM)


1994-1995-Postgres95
  *Support for SQL was added in 1994.
  *Released as Postgres95 in 1995
  *Re-released as PostgresSQL 6.0 in 1996
  *Establishment of the PostgreSQL Global Development Team.

Key Features of PostgreSQL
  *PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. 
  *It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).

PostgreSQL supports a large part of the SQL standard and offers many modern features including the following −

Complex SQL queries
SQL Sub-selects
Foreign keys
Trigger
Views
Transactions
Multiversion concurrency control (MVCC)
Streaming Replication (as of 9.0)
Hot Standby (as of 9.0)

3.Installation Of PostgreSQL
  *Command:-
   1. sudo apt-get update
   2. sudo apt-get upgrade
   3. sudo apt-get install postgresql postgresql-contrib

4.Start PostgreSQL CLI
  *service postgresql-To check the status of postgreSQL.
   Output:-Usage: /etc/init.d/postgresql {start|stop|restart|reload|force-reload|status}    [version ..]
  *service postgresql status-Running status of postgreSQL
  *sudo su postgres-To login into postgres
  *psql-To enter into postgreSQL terminal
  *\q-To exit the PostgreSQL CLI.

5.In PostgreSQL CLI
  * \l-To see all the databases present
  Output:-
                             List of databases
   Name    |  Owner   | Encoding | Collate | Ctype |   Access privileges   
-----------+----------+----------+---------+-------+-----------------------
 postgres  | postgres | UTF8     | en_IN   | en_IN | 
 template0 | postgres | UTF8     | en_IN   | en_IN | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_IN   | en_IN | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 test      | postgres | UTF8     | en_IN   | en_IN | 
 test1     | postgres | UTF8     | en_IN   | en_IN | 
(5 rows)
  
  * \du-To list the users
  
  Output:-
  List of roles
 Role name |                         Attributes                         | Member of 
-----------+------------------------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}

  *ALTER USER postgres WITH PASSWORD 'admin'; - To change the password of the default user    postgres.

  *CREATE USER user_1 WITH PASSWORD 'admin'; - To create new user.
  *ALTER USER user_1 WITH SUPERUSER; - To provide priveledge to the user.
  *DROP USER user_1; - To delete the user.
  *man psql-To know all the commands that can be used in psql.
  *psql -h localhost -p 5432 -U postgres DB_name - To connect to database directly

6.Datatype

*While creating a table, for each column,you specify a datatype,i.e,what kind of data you want to store in the table fields.

This enables several benefits −

*Consistency − Operations against columns of same data type give consistent results and are usually the fastest.

*Validation − Proper use of data types implies format validation of data and rejection of data outside the scope of data type.

*Compactness − As a column can store a single type of value, it is stored in a compact way.

*Performance − Proper use of data types gives the most efficient storage of data. The values stored can be processed quickly, which enhances the performance.

->Numeric Types
  *Numeric types consist of two-byte, four-byte, and eight-byte integers, four-byte and eight-byte floating-point numbers, and selectable-precision decimals. The following table lists the available types.






         Name			Storage Size	               Description				  Range
	smallint		2 bytes	small-range             integer			                -32768 to +32767
	
	integer		        4 bytes	                      typical choice for integer		-2147483648 to +2147483647
	
	bigint		        8 bytes	large-range              integer		                -9223372036854775808 to 9223372036854775807
	
	decimal		        variable	        user-specified precision,exact	                up to 131072 digits before the decimal point; up to 												                16383 digits after the decimal point
	
	numeric		        variable	        user-specified precision,exact	                up to 131072 digits before the decimal point; up to 												                 16383 digits after the decimal point
	
	real			4 bytes	                variable-precision,inexact		            6 decimal digits precision
	
	double precision	8 bytes	                variable-precision,inexact		            15 decimal digits precision
	
	smallserial		2 bytes	                small autoincrementing integer	                     1 to 32767
	
	serial			4 bytes	                 autoincrementing integer		             1 to 2147483647
	
	bigserial		8 bytes	                large autoincrementing integer	                     1 to 92233720368547758


->Monetary Types
  *The money type stores a currency amount with a fixed fractional precision. Values of the numeric, int, and bigint data types can be cast to money. Using Floating point numbers is not recommended to handle money due to the potential for rounding errors.

        Name	                     Storage Size	                                       Description	                         Range
       money	                     8 bytes	                                              currency amount	               -92233720368547758.08 to +92233720368547758.07

->Character Types
*The table given below lists the general-purpose character types available in PostgreSQL.
 
      S.No.	        Name & Description
	1		character varying(n), varchar(n)
			variable-length with limit

	2		character(n), char(n)
			fixed-length, blank padded

	3		text 
			variable unlimited length

->Binary Data Types
*The bytea data type allows storage of binary strings as in the table given below.

   Name	          Storage Size	     Description
   bytea	1 or 4 bytes plus the  actual binary string	variable-length binary string

->DATE/TIME TYPE
*PostgreSQL supports a full set of SQL date and time types, as shown in table below. Dates are counted according to the Gregorian calendar. Here, all the types have resolution of 1 microsecond / 14 digits except date type, whose resolution is day.
	
	Name		       		Storage Size		     Description			Low Value		High Value
	timestamp [(p)] 
	[without time zone ]			8 bytes	       both date and time (no time zone)	4713 BC		        294276 AD
	
	TIMESTAMPTZ				8 bytes	      both date and time, with time zone	4713 BC		        294276 AD

	date					4 bytes	date     (no time of day)			4713 BC		         5874897 AD

	time [ (p)] [ without time zone ]	8 bytes	     time of day (no date)			00:00:00		    24:00:00

	time [ (p)] with time zone		12 bytes	times of day only, with time zone	00:00:00+1459		24:00:00-1459

	interval [fields ] [(p) ]		12 bytes	time interval			       -178000000 years       178000000 years


->Boolean Type
*PostgreSQL provides the standard SQL type Boolean. The Boolean data type can have the states true, false, and a third state, unknown, which is represented by the SQL null value.

Name	Storage Size	Description
boolean	1 byte	state of true or false

->Enumerated Type
*Enumerated (enum) types are data types that comprise a static, ordered set of values. They are equivalent to the enum types supported in a number of programming languages.

Unlike other types, Enumerated Types need to be created using CREATE TYPE command. This type is used to store a static, ordered set of values. For example compass directions, i.e., NORTH, SOUTH, EAST, and WEST or days of the week as shown below −

CREATE TYPE week AS ENUM ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');


->Geometric Type
*Geometric data types represent two-dimensional spatial objects. The most fundamental type, the point, forms the basis for all of the other types.

Name	Storage Size	Representation	Description
point	16 bytes	Point on a plane	(x,y)
line	32 bytes	Infinite line (not fully implemented)	((x1,y1),(x2,y2))
lseg	32 bytes	Finite line segment	((x1,y1),(x2,y2))
box	32 bytes	Rectangular box	((x1,y1),(x2,y2))
path	16+16n bytes	Closed path (similar to polygon)	((x1,y1),...)
path	16+16n bytes	Open path	[(x1,y1),...]
polygon	40+16n	Polygon (similar to closed path)	((x1,y1),...)
circle	24 bytes	Circle	<(x,y),r> (center point and radius)


7.Array Type
PostgreSQL gives the opportunity to define a column of a table as a variable length multidimensional array. Arrays of any built-in or user-defined base type, enum type, or composite type can be created.

Declaration of Arrays
Array type can be declared as

CREATE TABLE monthly_savings (
   name text,
   saving_per_quarter integer[],
   scheme text[][]
);
or by using the keyword "ARRAY" as

CREATE TABLE monthly_savings (
   name text,
   saving_per_quarter integer ARRAY[4],
   scheme text[][]
);

Inserting values
Array values can be inserted as a literal constant, enclosing the element values within curly braces and separating them by commas. An example is shown below −

INSERT INTO monthly_savings 
VALUES (‘Manisha’, 
‘{20000, 14600, 23500, 13250}’, 
‘{{“FD”, “MF”}, {“FD”, “Property”}}’); 
Accessing Arrays
An example for accessing Arrays is shown below. The command given below will select the persons whose savings are more in second quarter than fourth quarter.

SELECT name FROM monhly_savings WHERE saving_per_quarter[2] > saving_per_quarter[4];
Modifying Arrays
An example of modifying arrays is as shown below.

UPDATE monthly_savings SET saving_per_quarter = '{25000,25000,27000,27000}'
WHERE name = 'Manisha';
or using the ARRAY expression syntax −

UPDATE monthly_savings SET saving_per_quarter = ARRAY[25000,25000,27000,27000]
WHERE name = 'Manisha';


Searching Arrays

An example of searching arrays is as shown below.

SELECT * FROM monthly_savings WHERE saving_per_quarter[1] = 10000 OR
saving_per_quarter[2] = 10000 OR
saving_per_quarter[3] = 10000 OR
saving_per_quarter[4] = 10000;
If the size of array is known, the search method given above can be used. Else, the following example shows how to search when the size is not known.

SELECT * FROM monthly_savings WHERE 10000 = ANY (saving_per_quarter);

8.CREATE DATABASE
*This command will create a database from PostgreSQL shell prompt, but you should have appropriate privilege to create a database. By default, the new database will be created by cloning the standard system database template1.

Syntax
The basic syntax of CREATE DATABASE statement is as follows −

CREATE DATABASE dbname;
where dbname is the name of a database to create.

Using createdb Command
PostgreSQL command line executable createdb is a wrapper around the SQL command CREATE DATABASE. The only difference between this command and SQL command CREATE DATABASE is that the former can be directly run from the command line and it allows a comment to be added into the database, all in one command.

9.CONNECT DATABASE
Syntax:-\c db_name

10.DROP DATABASE
This command drops a database. It removes the catalog entries for the database and deletes the directory containing the data. It can only be executed by the database owner. This command cannot be executed while you or anyone else is connected to the target database (connect to postgres or any other database to issue this command).

Syntax:- DROP DATABASE testdb;

10.CREATE TABLE
*The PostgreSQL CREATE TABLE statement is used to create a new table in any of the given database.

Syntax:-CREATE TABLE table_name(
   column1 datatype,
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
   PRIMARY KEY( one or more columns )
);
CREATE TABLE is a keyword, telling the database system to create a new table. The unique name or identifier for the table follows the CREATE TABLE statement.

eg:-create table employee(id BIGSERIAL PRIMARY KEY,first_name VARCHAR(20) NOT NULL,last_name VARCHAR(20) NOT NULL ,gender VARCHAR(5) NOT NULL,DOB DATE NOT NULL,email VARCHAR(50));

*You can verify if your table has been created successfully using \d command, which will be used to list down all the tables in an attached database.


11.DROP TABLE
The PostgreSQL DROP TABLE statement is used to remove a table definition and all associated data, indexes, rules, triggers, and constraints for that table.

Syntax
Basic syntax of DROP TABLE statement is as follows −

DROP TABLE table_name;

The message returned DROP TABLE indicates that drop command is executed successfully.

12.Schema
A schema is a named collection of tables. A schema can also contain views, indexes, sequences, data types, operators, and functions. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested. PostgreSQL statement CREATE SCHEMA creates a schema.

The basic syntax of CREATE SCHEMA is as follows −

CREATE SCHEMA name;
Where name is the name of the schema.

Syntax to Create Table in Schema
The basic syntax to create table in schema is as follows −

CREATE TABLE myschema.mytable (
...
);

Example
Let us see an example for creating a schema. Connect to the database testdb and create a schema myschema as follows −

testdb=# create schema myschema;
CREATE SCHEMA
The message "CREATE SCHEMA" signifies that the schema is created successfully.

Advantages of using a Schema
*It allows many users to use one database without interfering with each other.

*It organizes database objects into logical groups to make them more manageable.

*Third-party applications can be put into separate schemas so they do not collide with the names of other objects.


13.Insert
*The PostgreSQL INSERT INTO statement allows one to insert new rows into a table. One can insert a single row at a time or several rows as a result of a query.

Syntax:-
Basic syntax of INSERT INTO statement is as follows −

INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);

*Here, column1, column2,...columnN are the names of the columns in the table into which you want to insert data.

*The target column names can be listed in any order. The values supplied by the VALUES clause or query are associated with the explicit or implicit column list left-to-right.

Example:-
INSERT into employee(first_name,last_name,gender,DOB,email,salary)VALUES('Simran','Gupta','Female','1999-07-25','simran.gupta@gmail.com',40000),('Nimit','Mittal','Male','1996-12-06','nimit.mittal@gmail.com',60000),('Neeraj','Kumar','Male','1998-01-07','neeraj.kumar@gmail.com',20000),('Rachit','Garg','Male','1997-05-04','rachit.garg@gmail.com',50000);


14.Select

*PostgreSQL SELECT statement is used to fetch the data from a database table, which returns data in the form of result table. These result tables are called result-sets.

Syntax
The basic syntax of SELECT statement is as follows −

SELECT column1, column2, columnN FROM table_name;

Example:-
select id,salary from employee;

id | salary 
----+--------
  1 |  40000
  2 |  40000
  3 |  60000
  4 |  20000
  5 |  50000
  6 |  30000
  7 |  90000

Here, column1, column2...are the fields of a table, whose values you want to fetch. If you want to fetch all the fields available in the field then you can use the following syntax −

SELECT * FROM table_name;

Example:-Select * from employee;

 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  60000
  4 | Neeraj     | Kumar     | Male   | 1998-01-07 | neeraj.kumar@gmail.com        |  20000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000
(7 rows)

15.Operators

*An operator is a reserved word or a character used primarily in a PostgreSQL statement's WHERE clause to perform operation(s), such as comparisons and arithmetic operations.

Operators are used to specify conditions in a PostgreSQL statement and to serve as conjunctions for multiple conditions in a statement.

*Arithmetic operators
*Comparison operators
*Logical operators
*Bitwise operators

PostgreSQL Arithmetic Operators
Assume variable a holds 2 and variable b holds 3, then −

Example

Operator	Description	                                                           Example
+	Addition - Adds values on either side of the operator	                          a + b will give 5
-	Subtraction - Subtracts right hand operand from left hand operand	          a - b will give -1
*	Multiplication - Multiplies values on either side of the operator	          a * b will give 6
/	Division - Divides left hand operand by right hand operand	                  b / a will give 1
%	Modulus - Divides left hand operand by right hand operand and returns remainder	  b % a will give 1
^	Exponentiation - This gives the exponent value of the right hand operand	  a ^ b will give 8
|/	square root	                                                                 |/ 25.0 will give 5
||/	Cube root	                                                                 ||/ 27.0 will give 3
!	factorial	                                                                  5 ! will give 120
!!	factorial (prefix operator)	                                                  !! 5 will give 120

Example:test=# 
select 2+3;
 ?column? 
----------
        5
(1 row)


PostgreSQL Comparison Operators
Assume variable a holds 10 and variable b holds 20, then −


Operator	Description	                                                                                                            Example
=	Checks if the values of two operands are equal or not, if yes then condition becomes true.	                                (a = b) is not true.
!=	Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.	                (a != b) is true.
<>	Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.	                (a <> b) is true.
>	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.	        (a > b) is not true.
<	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.	        (a < b) is true.
>=	Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.	(a >= b) is not true.
<=	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.	(a <= b) is true.

Example:-
test=# select * From employee where salary>50000;
 id | first_name | last_name | gender |    dob     |         email          | salary 
----+------------+-----------+--------+------------+------------------------+--------
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com |  60000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com    |  90000
(2 rows)


PostgreSQL Logical Operators
Here is a list of all the logical operators available in PostgresSQL.

Operator & Description	
AND

The AND operator allows the existence of multiple conditions in a PostgresSQL statement's WHERE clause.

Eg:-
test=# select * From employee where gender='Female' AND salary=40000;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
(2 rows)



NOT

The NOT operator reverses the meaning of the logical operator with which it is used. Eg. NOT EXISTS, NOT BETWEEN, NOT IN etc. This is negate operator.
	
OR

The OR operator is used to combine multiple conditions in a PostgresSQL statement's WHERE clause.
Eg:-
select * from employee where gender='Female' Or salary>40000;
 id | first_name | last_name | gender |    dob     |             email             | salary 
----+------------+-----------+--------+------------+-------------------------------+--------
  1 | Srishti    | Garg      | Female | 1999-11-18 | srishti.garg@berylsystems.com |  40000
  2 | Simran     | Gupta     | Female | 1999-07-25 | simran.gupta@gmail.com        |  40000
  3 | Nimit      | Mittal    | Male   | 1996-12-06 | nimit.mittal@gmail.com        |  60000
  5 | Rachit     | Garg      | Male   | 1997-05-04 | rachit.garg@gmail.com         |  50000
  6 | Nishtha    | Goel      | Female | 1998-11-10 | nishtha.goel@gmail.com        |  30000
  7 | Veena      | Rao       | Female | 1989-08-04 | veena.rao@gmail.com           |  90000


The Bitwise operators supported by PostgreSQL are listed in the following table −

Operator	Description	                                                                                                            Example
&	Binary AND Operator copies a bit to the result if it exists in both operands.	                                                  (A & B) will give 12 which is 0000 1100
|	Binary OR Operator copies a bit if it exists in either operand.	                                                                   (A | B) will give 61 which is 0011 1101
~	Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.	                                                   (~A ) will give -61 which is 1100 0011 in 2's     c                                                                                                                                           complement form due to a signed binary number.
<<	Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.	            A << 2 will give 240 which is 1111 0000
>>	Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.	    A >> 2 will give 15 which is 0000 1111
#	bitwise XOR.	A # B will give 49 which is 00110001


Example:-
test=# select 60 | 13;
 ?column? 
----------
       61
(1 row)

test=# select (~60);
 ?column? 
----------
      -61
(1 row)

























